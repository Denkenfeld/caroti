<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Flappy Carrot Man: Rainbow Knife Tunnel</title>
  <style>
    body{margin:0;overflow:hidden;background:#222;font-family:'Comic Sans MS','Chalkboard SE',sans-serif;touch-action:none;user-select:none}
    #bgCanvas{position:fixed;inset:0;width:100%;height:100%;z-index:-1;background:#000}
    #gameCanvas{display:block;margin:0 auto;width:100%;height:100vh;max-width:600px;border-left:2px solid rgba(255,255,255,.25);border-right:2px solid rgba(255,255,255,.25);background:rgba(0,0,0,.10)}
    #ui{position:absolute;top:3%;width:100%;text-align:center;pointer-events:none;z-index:10;color:#fff;text-shadow:0 3px 10px rgba(0,0,0,.65)}
    #score{font-size:54px;font-weight:900;line-height:1}
    #meta{font-size:18px;font-weight:900;opacity:.95}
    #meta span{margin:0 10px}
    #start,#over{
      position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
      width:82%;max-width:440px;background:rgba(255,255,255,.95);
      border:4px solid #ff8c00;border-radius:18px;box-shadow:0 20px 50px rgba(0,0,0,.5);
      padding:22px;text-align:center;z-index:20
    }
    h1{margin:0 0 8px;color:#d35400;letter-spacing:1px}
    p{margin:8px 0;color:#333}
    #meme{margin:12px 0 6px;font-style:italic;color:#444;min-height:44px;display:flex;align-items:center;justify-content:center}
    button{
      background:linear-gradient(to bottom,#ff8c00,#e65100);color:#fff;border:none;cursor:pointer;
      padding:14px 34px;font-size:20px;font-weight:900;border-radius:999px;box-shadow:0 5px 0 #bf360c;
      transition:transform .1s,filter .1s
    }
    button:hover{transform:scale(1.05);filter:brightness(1.08)}
    button:active{transform:translateY(3px) scale(.97);box-shadow:0 2px 0 #bf360c}
    .hidden{display:none}
    #flash{position:fixed;inset:0;background:#ff1744;opacity:0;pointer-events:none;z-index:15;transition:opacity .08s;mix-blend-mode:overlay}
  </style>
</head>
<body>

<canvas id="bgCanvas"></canvas>
<div id="flash"></div>

<div id="ui">
  <div id="score">0</div>
  <div id="meta">
    <span id="lives">Lives: ‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span>
    <span id="size">Size: 1.00x</span>
    <span id="level">Level: 1</span>
  </div>
</div>

<div id="start">
  <h1>Rainbow Knife Tunnel</h1>
  <p>Click / Tap / Space to flap.</p>
  <p>+1 life per üçÑ. -1 life per hit.</p>
  <p>Every 10 knives passed ‚Üí next level (faster).</p>
  <button id="playBtn">PLAY</button>
</div>

<div id="over" class="hidden">
  <h1>GAME OVER</h1>
  <div id="meme">...</div>
  <p>Score: <span id="finalScore">0</span></p>
  <button id="againBtn">AGAIN</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
/* =========================
   BACKGROUND: rainbow + carrots
   ========================= */
const bgCanvas = document.getElementById('bgCanvas');
const bgCtx = bgCanvas.getContext('2d');
const bgCarrots = [];
const BG_COUNT = 240;

function resizeBg(){ bgCanvas.width = innerWidth; bgCanvas.height = innerHeight; }
addEventListener('resize', resizeBg); resizeBg();

class BgCarrot{
  constructor(){ this.reset(true); }
  reset(first=false){
    this.x = Math.random()*bgCanvas.width;
    this.y = first ? Math.random()*bgCanvas.height : bgCanvas.height + 100 + Math.random()*250;
    this.s = Math.random()*0.70 + 0.10;
    this.vy = Math.random()*1.35 + 0.35;
    this.vx = (Math.random()-0.5)*0.7;
    this.r = Math.random()*Math.PI*2;
    this.vr = (Math.random()-0.5)*0.05;
    this.a = Math.random()*0.28 + 0.08;
    this.bop = Math.random()*2.2 + 0.8;
    this.bopPhase = Math.random()*Math.PI*2;
  }
  update(t){
    this.y -= this.vy;
    this.x += this.vx + Math.sin(t*0.002 + this.bopPhase)*0.20;
    this.r += this.vr;
    if(this.y < -140) this.reset(false);
    if(this.x < -120) this.x = bgCanvas.width + 120;
    if(this.x > bgCanvas.width + 120) this.x = -120;
  }
  draw(t){
    bgCtx.save();
    bgCtx.translate(this.x, this.y);
    bgCtx.rotate(this.r);
    bgCtx.scale(this.s, this.s);
    bgCtx.globalAlpha = this.a;

    const dance = Math.sin(t*0.01 + this.bopPhase) * this.bop;
    bgCtx.fillStyle = '#ff8c00';
    bgCtx.beginPath(); bgCtx.ellipse(0, 0, 11, 34 + dance, 0, 0, Math.PI*2); bgCtx.fill();
    bgCtx.fillStyle = '#4caf50';
    bgCtx.beginPath(); bgCtx.ellipse(0, -34 - dance, 6, 14, Math.PI/6, 0, Math.PI*2); bgCtx.fill();
    bgCtx.restore();
  }
}
for(let i=0;i<BG_COUNT;i++) bgCarrots.push(new BgCarrot());

function drawRainbowBg(t){
  const hue = (t * 0.02) % 360;
  const g = bgCtx.createLinearGradient(0,0,0,bgCanvas.height);
  g.addColorStop(0, `hsl(${hue}, 90%, 55%)`);
  g.addColorStop(0.5, `hsl(${(hue+120)%360}, 90%, 55%)`);
  g.addColorStop(1, `hsl(${(hue+240)%360}, 90%, 55%)`);
  bgCtx.fillStyle = g;
  bgCtx.fillRect(0,0,bgCanvas.width,bgCanvas.height);
}

function bgLoop(t){
  drawRainbowBg(t);
  for(const c of bgCarrots){ c.update(t); c.draw(t); }
  requestAnimationFrame(bgLoop);
}
requestAnimationFrame(bgLoop);

/* =========================
   MAIN GAME
   ========================= */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const uiScore = document.getElementById('score');
const uiLives = document.getElementById('lives');
const uiSize  = document.getElementById('size');
const uiLevel = document.getElementById('level');
const flashEl = document.getElementById('flash');

const startEl = document.getElementById('start');
const overEl  = document.getElementById('over');
const memeEl  = document.getElementById('meme');
const finalScoreEl = document.getElementById('finalScore');

const music = new Audio('caroti.mp3');
music.loop = true;

function resizeGame(){
  canvas.width = Math.min(innerWidth, 600);
  canvas.height = innerHeight;
}
addEventListener('resize', resizeGame); resizeGame();

const memes = [
  "This kitchen is *un-peel-ievable*. ü•ï",
  "The knives said: 'slice to meet you'. üî™",
  "You got‚Ä¶ *rooted* by danger.",
  "Carrot man needs a helmet."
];

// State
let state='START';
let frame=0;
let score=0;
let level=1;
let lives=3;
let invuln=0;

let sizeMult=1.0;
const SIZE_UP=0.18;
const SIZE_DOWN_ON_HIT=0.15;

let speedBase=2.4;
let speedPerLevel=0.22;
let speed=2.4;

let spawnEvery=175;
let spinEvery=280;
let tunnelEvery=360;
let mushEvery=200;
let bunnyEvery=420;

function hearts(n){
  const shown = Math.min(n, 12);
  const extra = n>shown ? ` +${n-shown}` : '';
  return '‚ù§Ô∏è'.repeat(shown) + extra;
}
function updateUI(){
  uiScore.textContent = score;
  uiLives.textContent = `Lives: ${hearts(lives)}`;
  uiSize.textContent = `Size: ${sizeMult.toFixed(2)}x`;
  uiLevel.textContent = `Level: ${level}`;
}

function computeLevel(){
  level = Math.floor(score / 10) + 1;
  speed = speedBase + (level-1)*speedPerLevel;

  spawnEvery = Math.max(135, 175 - (level-1)*2);
  spinEvery  = Math.max(220, 280 - (level-1)*2);
  tunnelEvery= Math.max(280, 360 - (level-1)*2);
  mushEvery  = Math.max(160, 200 - (level-1)*1);
  bunnyEvery = Math.max(320, 420 - (level-1)*2);
}

// Input
function flap(){
  if(state!=='PLAY') return;
  player.vy = -7.8;
  if(music.paused) music.play().catch(()=>{});
}
addEventListener('mousedown', flap);
addEventListener('touchstart', (e)=>{ e.preventDefault(); flap(); }, {passive:false});
addEventListener('keydown', (e)=>{ if(e.code==='Space'||e.code==='ArrowUp') flap(); });

// Player: carrot man
const player = {
  x: 115,
  y: 200,
  vy: 0,
  gravity: 0.27,
  baseW: 44,
  baseH: 86,
  update(){
    this.vy += this.gravity;
    this.y += this.vy;
    const margin = 26;
    if(this.y < margin){ this.y = margin; this.vy = 0; }
    if(this.y > canvas.height - margin){ this.y = canvas.height - margin; this.vy = 0; }
  },
  hit(){
    if(invuln>0) return;
    lives -= 1;
    sizeMult = Math.max(0.65, sizeMult - SIZE_DOWN_ON_HIT);
    invuln = 75;
    flashEl.style.opacity = 0.50;
    setTimeout(()=>flashEl.style.opacity=0, 110);
    if(lives<=0) endGame();
  },
  draw(){
    ctx.save();
    ctx.translate(this.x, this.y);

    const w = this.baseW * sizeMult;
    const h = this.baseH * sizeMult;

    if(invuln>0 && Math.floor(frame/5)%2===0) ctx.globalAlpha=0.55;

    const rot = Math.min(Math.PI/6, Math.max(-Math.PI/6, this.vy*0.06));
    ctx.rotate(rot);

    ctx.strokeStyle = '#222';
    ctx.lineWidth = Math.max(3, 4*sizeMult);
    ctx.lineCap = 'round';

    const wob = Math.sin(frame*0.18) * (2.5*sizeMult);
    const armUp = Math.min(1, Math.max(0, (-this.vy)/8));
    const hipY = h*0.22;

    ctx.beginPath();
    ctx.moveTo(-w*0.15, hipY);
    ctx.quadraticCurveTo(-w*0.32, hipY + h*0.35, -w*0.22, hipY + h*0.52);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(w*0.15, hipY);
    ctx.quadraticCurveTo(w*0.32, hipY + h*0.35, w*0.22, hipY + h*0.52);
    ctx.stroke();

    const shoulderY = -h*0.05;
    const armLift = (-h*0.22) * armUp;

    ctx.beginPath();
    ctx.moveTo(-w*0.18, shoulderY);
    ctx.quadraticCurveTo(-w*0.45, shoulderY + wob + armLift, -w*0.55, shoulderY - 6*sizeMult + armLift);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(w*0.18, shoulderY);
    ctx.quadraticCurveTo(w*0.45, shoulderY - wob + armLift, w*0.55, shoulderY - 6*sizeMult + armLift);
    ctx.stroke();

    ctx.fillStyle = '#ff8c00';
    ctx.beginPath();
    ctx.ellipse(0, 0, w*0.30, h*0.42, 0, 0, Math.PI*2);
    ctx.fill();

    const hl = ctx.createRadialGradient(-w*0.12, -h*0.15, 2, -w*0.12, -h*0.15, w);
    hl.addColorStop(0,'rgba(255,255,255,0.35)');
    hl.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle = hl;
    ctx.beginPath();
    ctx.ellipse(-w*0.10, -h*0.10, w*0.18, h*0.22, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = '#4caf50';
    ctx.beginPath(); ctx.ellipse(0, -h*0.50, 10*sizeMult, 18*sizeMult, Math.PI/9, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(-8*sizeMult, -h*0.48, 9*sizeMult, 14*sizeMult, -Math.PI/10, 0, Math.PI*2); ctx.fill();

    const mood = (lives<=1) ? 3 : Math.min(3, Math.floor((sizeMult - 1)/0.7)+1);
    const eyeR = 6*sizeMult;
    const eyeY = -h*0.15;

    ctx.fillStyle='white';
    ctx.beginPath(); ctx.arc(-eyeR*0.95, eyeY, eyeR, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc( eyeR*0.95, eyeY, eyeR, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle='black';
    const pj = Math.sin(frame*0.25)*(0.7+mood*0.3);
    ctx.beginPath(); ctx.arc(-eyeR*0.95 + pj, eyeY, 2.1*sizeMult, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc( eyeR*0.95 + pj, eyeY, 2.1*sizeMult, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle='black';
    if(mood===1){
      ctx.beginPath(); ctx.arc(0, h*0.02, 7*sizeMult, 0, Math.PI, false); ctx.fill();
    } else if(mood===2){
      ctx.beginPath(); ctx.ellipse(0, h*0.08, 6*sizeMult, 10*sizeMult, 0, 0, Math.PI*2); ctx.fill();
    } else {
      ctx.beginPath(); ctx.ellipse(0, h*0.10, 9*sizeMult, 13*sizeMult, 0, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle='pink';
      ctx.beginPath(); ctx.ellipse(0, h*0.15, 5*sizeMult, 5*sizeMult, 0, 0, Math.PI*2); ctx.fill();
    }

    ctx.restore();
  }
};

function aabb(ax,ay,aw,ah,bx,by,bw,bh){
  return ax<bx+bw && ax+aw>bx && ay<by+bh && ay+ah>by;
}

function roundRect(x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
}
function drawKnife3D(x,y,w,h,dir){
  ctx.save();
  ctx.translate(x,y);
  ctx.shadowColor='rgba(0,0,0,0.55)';
  ctx.shadowBlur=10;
  ctx.shadowOffsetX=5;
  ctx.shadowOffsetY=5;

  const handleH=52;

  if(dir==='down'){
    let hg=ctx.createLinearGradient(0,-handleH,w,-handleH);
    hg.addColorStop(0,'#1f2b35'); hg.addColorStop(0.35,'#5db6c8'); hg.addColorStop(1,'#141b22');
    ctx.fillStyle=hg; roundRect(5,-handleH,w-10,handleH,7); ctx.fill();
    ctx.fillStyle='#f1c40f';
    ctx.beginPath(); ctx.arc(w/2,-38,4,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(w/2,-16,4,0,Math.PI*2); ctx.fill();

    const bg=ctx.createLinearGradient(0,0,w,0);
    bg.addColorStop(0,'#9aa4aa'); bg.addColorStop(0.18,'#ffffff'); bg.addColorStop(0.52,'#e8eef1'); bg.addColorStop(1,'#6f7a80');
    ctx.fillStyle=bg;

    ctx.beginPath();
    ctx.moveTo(6,0); ctx.lineTo(w-6,0);
    ctx.lineTo(w-6,h-34);
    ctx.quadraticCurveTo(w*0.5,h,6,h-2);
    ctx.closePath(); ctx.fill();

    ctx.strokeStyle='rgba(255,255,255,0.85)';
    ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(12,0); ctx.lineTo(12,Math.max(0,h-10)); ctx.stroke();
  } else {
    let hg=ctx.createLinearGradient(0,0,w,0);
    hg.addColorStop(0,'#1f2b35'); hg.addColorStop(0.35,'#5db6c8'); hg.addColorStop(1,'#141b22');
    ctx.fillStyle=hg; roundRect(5,0,w-10,handleH,7); ctx.fill();
    ctx.fillStyle='#f1c40f';
    ctx.beginPath(); ctx.arc(w/2,16,4,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(w/2,38,4,0,Math.PI*2); ctx.fill();

    const tipY = -h + handleH;
    const bg=ctx.createLinearGradient(0,0,w,0);
    bg.addColorStop(0,'#9aa4aa'); bg.addColorStop(0.18,'#ffffff'); bg.addColorStop(0.52,'#e8eef1'); bg.addColorStop(1,'#6f7a80');
    ctx.fillStyle=bg;

    ctx.beginPath();
    ctx.moveTo(6,handleH); ctx.lineTo(w-6,handleH);
    ctx.lineTo(w-6,tipY+34);
    ctx.quadraticCurveTo(w*0.5,tipY,6,tipY+2);
    ctx.closePath(); ctx.fill();

    ctx.strokeStyle='rgba(255,255,255,0.85)';
    ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(12,handleH); ctx.lineTo(12,tipY+10); ctx.stroke();
  }
  ctx.restore();
}

function drawSpinningKnife(cx, cy, L, angle){
  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(angle);

  const w = 18;
  const h = L;
  const bg = ctx.createLinearGradient(-w/2,0,w/2,0);
  bg.addColorStop(0,'#7f8c8d');
  bg.addColorStop(0.25,'#ffffff');
  bg.addColorStop(0.6,'#ecf0f1');
  bg.addColorStop(1,'#7f8c8d');
  ctx.fillStyle = bg;

  ctx.beginPath();
  ctx.moveTo(-w/2, -h/2);
  ctx.lineTo( w/2, -h/2);
  ctx.lineTo( w/2,  h/2 - 20);
  ctx.quadraticCurveTo(0, h/2, -w/2, h/2 - 20);
  ctx.closePath();
  ctx.fill();

  const hg = ctx.createLinearGradient(-w/2, -h/2 - 28, w/2, -h/2 - 28);
  hg.addColorStop(0,'#1f2b35'); hg.addColorStop(0.4,'#5db6c8'); hg.addColorStop(1,'#141b22');
  ctx.fillStyle = hg;
  roundRect(-w/2, -h/2 - 32, w, 32, 6);
  ctx.fill();

  ctx.fillStyle='#f1c40f';
  ctx.beginPath(); ctx.arc(0, -h/2 - 20, 3, 0, Math.PI*2); ctx.fill();

  ctx.restore();
}

function drawHorizontalKnife(x, y, length, thickness, dir){
  ctx.save();
  ctx.translate(x,y);

  ctx.shadowColor='rgba(0,0,0,0.45)';
  ctx.shadowBlur=8;
  ctx.shadowOffsetX=4;
  ctx.shadowOffsetY=4;

  const bladeG = ctx.createLinearGradient(0,0,0,thickness);
  bladeG.addColorStop(0,'#ffffff');
  bladeG.addColorStop(0.5,'#dfe6e9');
  bladeG.addColorStop(1,'#7f8c8d');
  ctx.fillStyle = bladeG;

  ctx.beginPath();
  if(dir==='right'){
    ctx.moveTo(0,0);
    ctx.lineTo(length-22,0);
    ctx.quadraticCurveTo(length, thickness/2, length-22, thickness);
    ctx.lineTo(0, thickness);
  } else {
    ctx.moveTo(0,0);
    ctx.lineTo(22,0);
    ctx.quadraticCurveTo(0, thickness/2, 22, thickness);
    ctx.lineTo(length, thickness);
    ctx.lineTo(length,0);
  }
  ctx.closePath();
  ctx.fill();

  ctx.fillStyle = '#1f2b35';
  if(dir==='right') roundRect(-26, 2, 26, thickness-4, 6);
  else roundRect(length, 2, 26, thickness-4, 6);
  ctx.fill();

  ctx.restore();
}

function drawMushroom(x,y,scale=1){
  ctx.save(); ctx.translate(x,y); ctx.scale(scale,scale);
  ctx.fillStyle='#f5f5f5';
  ctx.beginPath(); ctx.roundRect(-6,-2,12,18,6); ctx.fill();
  const capG=ctx.createRadialGradient(-6,-10,2,0,-10,28);
  capG.addColorStop(0,'#ffebee'); capG.addColorStop(0.35,'#ff5252'); capG.addColorStop(1,'#b71c1c');
  ctx.fillStyle=capG;
  ctx.beginPath(); ctx.ellipse(0,-10,18,12,0,0,Math.PI*2); ctx.fill();
  ctx.fillStyle='rgba(255,255,255,0.9)';
  for(const s of [[-8,-12,3],[2,-14,2.5],[9,-9,2.8],[-2,-7,2.2]]){
    ctx.beginPath(); ctx.arc(s[0],s[1],s[2],0,Math.PI*2); ctx.fill();
  }
  ctx.restore();
}

function drawBunny(x,y,scale=1){
  ctx.save(); ctx.translate(x,y); ctx.scale(scale,scale);
  ctx.fillStyle='rgba(0,0,0,0.15)';
  ctx.beginPath(); ctx.ellipse(0,18,18,6,0,0,Math.PI*2); ctx.fill();
  ctx.fillStyle='white'; ctx.strokeStyle='rgba(0,0,0,0.1)'; ctx.lineWidth=2;
  ctx.beginPath(); ctx.ellipse(-8,-18,6,16,-0.2,0,Math.PI*2); ctx.fill(); ctx.stroke();
  ctx.beginPath(); ctx.ellipse( 8,-18,6,16, 0.2,0,Math.PI*2); ctx.fill(); ctx.stroke();
  ctx.fillStyle='pink';
  ctx.beginPath(); ctx.ellipse(-8,-18,3,11,-0.2,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse( 8,-18,3,11, 0.2,0,Math.PI*2); ctx.fill();
  ctx.fillStyle='white';
  ctx.beginPath(); ctx.arc(0,0,18,0,Math.PI*2); ctx.fill();
  ctx.fillStyle='black';
  ctx.beginPath(); ctx.arc(-6,-2,2.5,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc( 6,-2,2.5,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(0,6,5,0,Math.PI,false); ctx.fill();
  ctx.fillStyle='white'; ctx.fillRect(-3,6,3,5); ctx.fillRect(0,6,3,5);
  ctx.restore();
}

const knifePairs = [];
const spinners  = [];
const tunnels   = [];
const mushrooms = [];
const bunnies   = [];

function spawnKnifePair(){
  const gap = 300 - Math.min(70, (level-1)*3);
  const minY = 150;
  const maxY = canvas.height - 150;
  const centerY = Math.random()*(maxY-minY) + minY;

  const moving = Math.random() < 0.22;
  const amp = moving ? (10 + Math.random()*28) : 0;
  const freq = moving ? (0.010 + Math.random()*0.012) : 0;
  const phase = Math.random()*Math.PI*2;

  knifePairs.push({ x: canvas.width+30, centerY, gap, w: 54, moving, amp, freq, phase, passed:false });
}

function spawnSpinner(){
  spinners.push({
    x: canvas.width + 40,
    y: 120 + Math.random()*(canvas.height-240),
    L: 120 + Math.random()*90,
    ang: Math.random()*Math.PI*2,
    av: (Math.random()<0.5 ? -1 : 1) * (0.06 + Math.random()*0.04)
  });
}

function spawnTunnel(){
  const segW = 160;
  const centerY = 140 + Math.random()*(canvas.height-280);
  const gap = 190 - Math.min(40, (level-1)*2);

  tunnels.push({
    x: canvas.width + 30,
    w: segW,
    cy: centerY,
    gap,
    phase: Math.random()*Math.PI*2,
    amp: 10 + Math.random()*10
  });
}

function spawnMushroom(){
  mushrooms.push({ x: canvas.width+30, y: 110 + Math.random()*(canvas.height-220), bobPhase: Math.random()*Math.PI*2 });
}

function spawnBunny(){
  bunnies.push({
    x: canvas.width+60,
    y: 110 + Math.random()*(canvas.height-220),
    vx: speed + 0.5 + Math.random()*0.7,
    vy: (Math.random()-0.5)*0.55,
    t: 0
  });
}

function applyMushroom(){
  lives += 1;
  sizeMult = Math.min(5.0, sizeMult + SIZE_UP);
}

function endGame(){
  state='OVER';
  overEl.classList.remove('hidden');
  finalScoreEl.textContent = score;
  memeEl.textContent = memes[Math.floor(Math.random()*memes.length)];
}

function reset(){
  frame=0; score=0; level=1; lives=3; invuln=0; sizeMult=1.0;
  speedBase=2.4; speedPerLevel=0.22; speed=2.4;

  knifePairs.length=0; spinners.length=0; tunnels.length=0;
  mushrooms.length=0; bunnies.length=0;

  player.y=200; player.vy=0;
  updateUI();
}

function startGame(){
  startEl.classList.add('hidden');
  overEl.classList.add('hidden');
  reset();
  state='PLAY';
  if(music.paused) music.play().catch(()=>{});
  requestAnimationFrame(loop);
}

function restart(){
  overEl.classList.add('hidden');
  reset();
  state='PLAY';
  if(music.paused) music.play().catch(()=>{});
  requestAnimationFrame(loop);
}

function loop(){
  if(state!=='PLAY') return;

  ctx.clearRect(0,0,canvas.width,canvas.height);
  frame++;
  if(invuln>0) invuln--;

  computeLevel();

  if(frame % spawnEvery === 0) spawnKnifePair();
  if(frame % spinEvery === 0 && level >= 2) spawnSpinner();
  if(frame % tunnelEvery === 0 && level >= 3) spawnTunnel();
  if(frame % mushEvery === 0) spawnMushroom();
  if(frame % bunnyEvery === 0 && level >= 2) spawnBunny();

  player.update();

  const pw = 24 * sizeMult;
  const ph = 46 * sizeMult;
  const px = player.x - pw/2;
  const py = player.y - ph/2;

  for(let i=knifePairs.length-1;i>=0;i--){
    const k = knifePairs[i];
    k.x -= speed;

    const wob = k.moving ? Math.sin(frame*k.freq + k.phase)*k.amp : 0;
    const cy = k.centerY + wob;

    const topH = cy - k.gap/2;
    const botY = cy + k.gap/2;
    const botH = canvas.height - botY;

    drawKnife3D(k.x, 0, k.w, Math.max(10, topH), 'down');
    drawKnife3D(k.x, canvas.height, k.w, Math.max(10, botH), 'up');

    const kx = k.x + 10;
    const kw = k.w - 20;

    const hitTop = aabb(px,py,pw,ph, kx, 0, kw, topH);
    const hitBot = aabb(px,py,pw,ph, kx, botY, kw, botH);
    if((hitTop||hitBot) && invuln<=0) player.hit();

    if(!k.passed && k.x + k.w < player.x){
      score += 1;
      k.passed = true;
      updateUI();
    }
    if(k.x + k.w < -90) knifePairs.splice(i,1);
  }

  for(let i=spinners.length-1;i>=0;i--){
    const s = spinners[i];
    s.x -= speed * 0.95;
    s.ang += s.av;

    drawSpinningKnife(s.x, s.y, s.L, s.ang);

    const hbW = 38;
    const hbH = 38;
    if(aabb(px,py,pw,ph, s.x - hbW/2, s.y - hbH/2, hbW, hbH) && invuln<=0){
      player.hit();
    }

    if(s.x < -120) spinners.splice(i,1);
  }

  for(let i=tunnels.length-1;i>=0;i--){
    const t = tunnels[i];
    t.x -= speed;

    const breathe = Math.sin(frame*0.04 + t.phase) * t.amp;
    const cy = t.cy + breathe;

    const topY = cy - t.gap/2;
    const botY = cy + t.gap/2;

    const thick = 26;

    drawHorizontalKnife(t.x, topY - thick, t.w, thick, 'right');
    drawHorizontalKnife(t.x, botY, t.w, thick, 'right');

    const inset = 6;
    const hx = t.x + inset;
    const hw = t.w - inset*2;

    const hitTop = aabb(px,py,pw,ph, hx, topY - thick + 2, hw, thick - 4);
    const hitBot = aabb(px,py,pw,ph, hx, botY + 2, hw, thick - 4);
    if((hitTop||hitBot) && invuln<=0) player.hit();

    if(t.x + t.w < -120) tunnels.splice(i,1);
  }

  for(let i=mushrooms.length-1;i>=0;i--){
    const m = mushrooms[i];
    m.x -= speed*0.82;
    const bob = Math.sin(frame*0.06 + m.bobPhase)*5;
    drawMushroom(m.x, m.y+bob, 1.0);

    if(aabb(px,py,pw,ph, m.x-18, (m.y+bob)-22, 36, 44)){
      applyMushroom();
      mushrooms.splice(i,1);
      updateUI();
    } else if(m.x < -70){
      mushrooms.splice(i,1);
    }
  }

  for(let i=bunnies.length-1;i>=0;i--){
    const b = bunnies[i];
    b.t += 1;
    b.x -= b.vx;

    const chase = (player.y - b.y) * 0.005;
    b.y += b.vy + chase + Math.sin((frame+b.t)*0.08)*0.55;
    b.y = Math.max(55, Math.min(canvas.height-55, b.y));

    drawBunny(b.x, b.y, 1.0);

    if(aabb(px,py,pw,ph, b.x-20, b.y-20, 40, 40) && invuln<=0){
      player.hit();
    }
    if(b.x < -90) bunnies.splice(i,1);
  }

  player.draw();

  updateUI();
  requestAnimationFrame(loop);
}

// Mobile-friendly button handlers - FIXED FOR MOBILE
document.getElementById('playBtn').addEventListener('click', startGame);
document.getElementById('playBtn').addEventListener('touchend', function(e) {
  e.preventDefault();
  startGame();
}, {passive: false});

document.getElementById('againBtn').addEventListener('click', restart);
document.getElementById('againBtn').addEventListener('touchend', function(e) {
  e.preventDefault();
  restart();
}, {passive: false});
</script>
</body>
</html>

